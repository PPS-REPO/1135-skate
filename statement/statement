# 문제

당신은 주어진 스케이트 코스에서 $Q$번의 스케이트 연습을 하려고 한다. 전체 코스는 총 $N + 2$개의 지점으로 이루어져 있으며, 각 지점은 고유한 번호가 부여되어 있다. 지점의 번호는 $0$번부터 시작하여 $N + 1$번까지, 즉 $0, 1, 2, \dots, N, N+1$ 순서로 붙어 있다.

$i$번째 연습에는 $(L_i - 1)$번 지점에서 연습을 시작하여 $L_i$번 지점과 $R_i$번 지점을 거쳐 $(R_i + 1)$번 지점에서 연습을 끝낸다. 따라서 $i$번째 연습 경로는 $[L_i - 1, L_i, \dots, R_i, R_i + 1]$와 같다. 매 연습 경로는 다를 수도 있다.

이 연습은 $(L_i - 1)$번 지점에서 $0$의 속력으로 출발하여, $(R_i + 1)$번 지점에 $0$의 속력으로 도착한다. $k$번 지점에는 속력 제한 $V_k$가 있어, 다음으로 방문할 지점의 속력 제한을 초과하지 않도록 이동하는 사이에 속력을 조절해야 한다. 속력을 높일 때는 원하는 만큼 높일 수 있지만, 속력을 낮추는 경우에는 마지막으로 방문했던 지점에서의 속력에서 $1$만큼만 낮출 수 있다.

단, $(L_i - 1)$번 지점과 $(R_i + 1)$번 지점을 제외한 위치에서 속력은 $0$이 될 수 없다. 속력을 변경하지 않고 그대로 유지하는 것도 가능하다. 지점별 속도 제한 $V_k$는 모든 연습에서 동일하다.

연습의 성과는 각 지점에서의 속력의 합과 같으므로 이를 최대화하려고 한다. 스케이트 코스의 속력 제한이 주어졌을 때, 각 연습마다 얻을 수 있는 최대 연습의 성과를 구해보자. 단 성과가 너무 커질 수 있으므로, 최대 성과를 $998\ 244\ 353$으로 나눈 나머지를 출력하여라.

# 입력
이 문제에서 $V_k,L_i,R_i$ 값은 직접 주어지지 않고 유사 난수 생성기로 생성한 것을 사용할 것이다. 자세한 사용법은 아래에 기술되어 있다.

첫 번째 줄에 양의 정수 $N$이 주어진다. ($1\leq N\leq 10^6$)

두 번째 줄에 $V_k$의 값을 생성하기 위한 세 개의 정수 $V_{min}, V_{max}, V_{seed}$가 공백을 두고 주어진다. ($1\leq V_{min},V_{max},V_{seed}\leq 10^9$|단, $1\leq k\leq N$)

세 번째 줄에 양의 정수 $Q$가 주어진다. ($1\leq Q\leq 10^5$)

네 번째 줄에 $L_i, R_i$ 값을 생성하기 위한 다섯 개의 정수 $L_{min},L_{max},R_{min},R_{max},Q_{seed}$가 공백을 두고 주어진다. ($1\leq L_{min}\leq (L_{max},R_{min})\leq R_{max}\leq N, 1\leq Q_{seed}\leq 10^9$|단, $1\leq i\leq Q$)\

# 출력
$Q$개의 줄에 걸쳐 $i$번째 줄에는 $i$번째 연습의 최대 성과를 $786\ 433$으로 나눈 나머지를 출력하여라.

# 유사 난수 생성기
다음은 각 언어별로 문제의 유사 난수 생성기를 구현한 코드이다. 언어에 맞는 코드를 그대로 사용하면 된다. 유사 난수 생성 방법과 문제의 풀이와는 관련이 없음이 보장된다.

- C/C++ : https://onlinegdb.com/dpcDkEEWx
- Python : https://onlinegdb.com/LL8tg_USZ

함수 목록
- get_random(x, y) : x 이상 y 이하의 범위에서 임의의 정수를 반환한다.
- ready(seeds) : 첫 seed 값을 설정한다.

$V_k, L_i, R_i$ 값을 구하는 방법
- $V_k$ : 먼저 ready($Q_{seed}$)를 호출한 뒤, get_random($V_{min}, V_{max}$)를 $N$번 호출하여 반환되는 값을 순서대로 $V_1,V_2,\cdots,V_N$으로 정한다. 이렇게 구한 값들은 항상 $1\leq V_k \leq 10^9$를 만족한다. 
- $L_i, R_i$ : 먼저 ready($Q_{seed}$)를 호출한 뒤, get_random($L_{min},L_{max}$)를 호출하여 $L_i$ 값을 구하고, 이어서 get_random(max($L_i, R_{min}$), $R_{max}$)를 호출하여 $R_i$ 값을 구한다. 이 과정을 $Q$번 반복하여, 순서대로 $L_1,R_1,L_2,R_2,\cdots,L_Q,R_Q$를 정한다. 이렇게 구한 값들은 항상 $1\leq L_i \leq R_i \leq N$을 만족한다.

즉 함수 호출 흐름은 다음과 같다 :

ready($V_{seed}$) -> get_random($V_{min},V_{max}$) -> $\cdots $ -> get_random($V_{min},V_{max}$) -> ready($Q_{seed}$) -> get_random($L_{min},L_{max}$) -> get_random(max($L_i,R_{min}$),$R_{max}$) -> $\cdots$ -> get_random($L_{min},L_{max}$) -> get_random(max($L_i,R_{min}$),$R_{max}$)